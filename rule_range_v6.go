package ipacl

// This file is generated by `go generic`. DO NOT EDIT.

import (
	"log"
	"strings"
	"unicode"
)

type ruleRangeV6 struct {
	ipRange v6Range
	action  Action
}

func ruleRangeV6FromCIDR(rule Rule) ruleRangeV6 {
	return ruleRangeV6{
		ipRange: v6RangeFromPrefix(rule.target),
		action:  rule.action,
	}
}

// ruleRangeV6ListAddRange returns a new list with r added to list.
// If an element in list overlaps r, overlapping part is not added.
// Adjacent elements of the same action are concatenated.
// Elements in list must be non-overlapping and be sorted in increasing order.
func ruleRangeV6ListAddRange(list []ruleRangeV6, r ruleRangeV6) []ruleRangeV6 {
	if debug {
		log.Printf("ruleRangeV6ListAddRange start, list=%s, r=%s", list, r)
	}
	var res []ruleRangeV6

	appendOrExtend := func(s ruleRangeV6) {
		j := len(res)
		if j > 0 && res[j-1].action == s.action && res[j-1].ipRange.end.Next().Compare(s.ipRange.start) == 0 {
			res[j-1].ipRange.end = s.ipRange.end
		} else {
			res = append(res, s)
		}
	}

	rest := r
	restEmpty := false
	i := 0
	for i < len(list) {
		s := list[i]
		if debug {
			log.Printf("ruleRangeV6ListAddRange for loop, i=%d, len=%d, s=%s, rest=%s", i, len(list), s, rest)
		}
		if s.ipRange.start.Compare(rest.ipRange.start) <= 0 {
			appendOrExtend(s)
			i++
			sEndNext := s.ipRange.end.Next()
			if sEndNext.Compare(rest.ipRange.start) > 0 || sEndNext.IsFirst() {
				rest.ipRange.start = sEndNext
			}
			if debug {
				log.Printf("ruleRangeV6ListAddRange after add s, i=%d, rest=%s, res=%s", i, rest, formatRuleRangeV6List(res))
			}
		} else {
			end := rest.ipRange.end.Min(s.ipRange.start.Prev())
			appendOrExtend(ruleRangeV6{
				ipRange: v6Range{
					start: rest.ipRange.start,
					end:   end,
				},
				action: rest.action,
			})
			rest.ipRange.start = end.Next()
			if debug {
				log.Printf("ruleRangeV6ListAddRange after add partial or whole rest, i=%d, rest=%s, res=%s", i, rest, formatRuleRangeV6List(res))
			}
		}
		if rest.ipRange.start.Compare(rest.ipRange.end) > 0 || rest.ipRange.start.IsFirst() {
			if debug {
				log.Printf("ruleRangeV6ListAddRange set restEmpty to true, rest=%s", rest)
			}
			restEmpty = true
			break
		}
	}
	if restEmpty {
		for i < len(list) {
			appendOrExtend(list[i])
			i++
			if debug {
				log.Printf("ruleRangeV6ListAddRange added list[i] in loop#2, i=%d, len=%d, res=%s", i, len(list), formatRuleRangeV6List(res))
			}
		}
	} else {
		appendOrExtend(rest)
		if debug {
			log.Printf("ruleRangeV6ListAddRange added rest, res=%s", formatRuleRangeV6List(res))
		}
	}
	return res
}

func (r ruleRangeV6) String() string {
	var b strings.Builder
	if r.action == Deny {
		b.WriteByte('!')
	}
	b.WriteString(r.ipRange.start.String())
	if r.ipRange.end.Compare(r.ipRange.start) != 0 {
		b.WriteByte('-')
		b.WriteString(r.ipRange.end.String())
	}
	return b.String()
}

func parseRuleRangeV6(s string) (ruleRangeV6, error) {
	action := Allow
	if strings.HasPrefix(s, "!") {
		action = Deny
		s = s[1:]
	}
	before, after, found := strings.Cut(s, "-")
	start, err := parseV6Addr(before)
	if err != nil {
		return ruleRangeV6{}, err
	}
	var end v6Addr
	if found {
		end, err = parseV6Addr(after)
		if err != nil {
			return ruleRangeV6{}, err
		}
	} else {
		end = start
	}
	return ruleRangeV6{
		ipRange: v6Range{start: start, end: end},
		action:  action,
	}, nil
}

func mustParseRuleRangeV6(s string) ruleRangeV6 {
	rule, err := parseRuleRangeV6(s)
	if err != nil {
		panic(err.Error())
	}
	return rule
}

func parseRuleRangeV6List(s string) ([]ruleRangeV6, error) {
	fields := strings.FieldsFunc(s, func(r rune) bool {
		return unicode.IsSpace(r) || r == ','
	})
	rules := make([]ruleRangeV6, 0, len(fields))
	for _, field := range fields {
		rule, err := parseRuleRangeV6(field)
		if err != nil {
			return nil, err
		}
		rules = append(rules, rule)
	}
	return rules, nil
}

func mustParseRuleRangeV6List(s string) []ruleRangeV6 {
	rules, err := parseRuleRangeV6List(s)
	if err != nil {
		panic(err.Error())
	}
	return rules
}

func formatRuleRangeV6List(rules []ruleRangeV6) string {
	var b strings.Builder
	for i, rule := range rules {
		if i > 0 {
			b.WriteString(", ")
		}
		b.WriteString(rule.String())
	}
	return b.String()
}
